# IOHIDFamily Use After Free

## Bug summary

- IOKit bug
- Race condition (release vs use)
- Finally trigger Use After Free

## Environment

- maybe.. OS X El Capltan 10.11.4.. 
- tested on 2015 mac book maybe..


## Description

이 버그를 찾은 방법은 소스 코드 오디팅을 통해 찾았습니다. 

해당 버그가 있는 드라이버는 IOHIDFamily이고 이전에 같은 방식이 보고 된적이 있습니다. (prior research)

이전에 보고된 버그는 이벤트 큐를 초기화하는 부분에서 타입이 커널 큐라고 한다면, 해당 커널 큐를 릴리즈 시키는 것이였습니다. 

결국 해당 부분을 레이스 컨디션 시켜서,  널로 초기화 되기 전에 더블 릴리즈 시킬 수 있는 취약점이었습니다.

```
kernelQueue->release();
kernelQueue = NULL;
```

패치 됬죠.

그런데 다른 방식으로 취약점을 트리거 시킬 수 있었습니다.

해당 드라이버에서 커널 큐는  UserClient의 registerNotificationPort 메서드나 clientMemoryForType를 통해서

다양한 부분에서 사용될 수 있습니다.

IOConnectMapMemory라는 유저쪽 함수는 clientMemoryForType를 IOConnectSetNotificationPort라는 유저쪽 함수는 registerNotificationPort를 호출 할 수 있습니다.

결론은 이전에는 커널 큐를 없애는 부분애서 레이스 컨디션을 노렸다면 

이번에는 사용하는 커널 큐를 없애는 부분과 사용하는 부분에서 레이스 컨디션을 노리는 겁니다.

opensource.apple.com에 있는 소스로 보았을 때, 

```
IOReturn IOHIDEventSystemUserClient::clientMemoryForType( UInt32 type, UInt32 * flags, IOMemoryDescriptor ** memory )
{    
	IODataQueue *   eventQueue = NULL;
	IOReturn        ret = kIOReturnNoMemory;
	if (type == kIOHIDEventSystemKernelQueueID)
    	eventQueue = kernelQueue;	
    else
    	eventQueue  = copyDataQueueWithID(type);
    if ( eventQueue ) 
    {       
    	IOMemoryDescriptor * desc = NULL;
        *flags = 0;
        desc = eventQueue->getMemoryDescriptor();
        if ( desc ) 
        {            
        	desc->retain();            
        	ret = kIOReturnSuccess;        
        }
        *memory = desc;		
        if (type != kIOHIDEventSystemKernelQueueID)
        	eventQueue->release();
    } 
    else 
    {       
    	ret = kIOReturnBadArgument;    
    }
    return ret;
}
```

```
IOReturn IOHIDEventSystemUserClient::destroyEventQueueGated(void*p1,void*p2,void*,void*)
{    
	UInt32          type       = (uintptr_t) p1;    
	UInt32          queueID    = (uintptr_t) p2;    
	IODataQueue *   eventQueue = NULL;
	if (queueID == kIOHIDEventSystemKernelQueueID) 
	{		
		eventQueue = kernelQueue;		
		type = kIOHIDEventQueueTypeKernel;	
	} 
	else 
	{		
		eventQueue = copyDataQueueWithID(queueID);		type = kIOHIDEventQueueTypeUser;	
	}
    if ( !eventQueue )        
    	return kIOReturnBadArgument;
    switch ( type ) 
    {        
    	case kIOHIDEventQueueTypeKernel:			
    		kernelQueue->setState(false);			
    		if (owner) owner->unregisterEventQueue(kernelQueue);			
    		kernelQueue->release();			
    		kernelQueue = NULL;			
    		break;        
    	case kIOHIDEventQueueTypeUser:            
    		if (userQueues)                
    			userQueues->removeObject(eventQueue);
    		removeIDForDataQueue(eventQueue);			
    		eventQueue->release();           
            break;    
    }
    return kIOReturnSuccess;
}
```

이 두 함수에서 아래 두 부분을 레이스 컨디션 한 것 입니다.

```
  desc = eventQueue->getMemoryDescriptor();     
```

    
      kernelQueue->release();
      kernelQueue = NULL;	

다음에 영어로 바꿔야지...

## Prior research

- https://marcograss.github.io/security/apple/cve/2016/05/16/cve-2016-1824-apple-iohidfamily-racecondition.html
- https://bugs.chromium.org/p/project-zero/issues/detail?id=620

## Reference

- https://support.apple.com/ko-kr/HT206567